{
  "blogPosts": [
    {
      "id": "/2022/11/16/vite-react-extension",
      "metadata": {
        "permalink": "/blog/2022/11/16/vite-react-extension",
        "editUrl": "https://github.com/sayaku/sayaku.github.io/edit/main/blog/2022-11-16-vite-react-extension/index.mdx",
        "source": "@site/blog/2022-11-16-vite-react-extension/index.mdx",
        "title": "vite-react-extension",
        "description": "繼上一次vite-react範本設定",
        "date": "2022-11-16T12:00:12.000Z",
        "formattedDate": "2022年11月16日",
        "tags": [
          {
            "label": "vite",
            "permalink": "/blog/tags/vite"
          },
          {
            "label": "react",
            "permalink": "/blog/tags/react"
          },
          {
            "label": "sass",
            "permalink": "/blog/tags/sass"
          },
          {
            "label": "tailwindcss",
            "permalink": "/blog/tags/tailwindcss"
          },
          {
            "label": "redux",
            "permalink": "/blog/tags/redux"
          },
          {
            "label": "redux-observable",
            "permalink": "/blog/tags/redux-observable"
          },
          {
            "label": "rxjs",
            "permalink": "/blog/tags/rxjs"
          },
          {
            "label": "observable-hooks",
            "permalink": "/blog/tags/observable-hooks"
          },
          {
            "label": "axios-observable",
            "permalink": "/blog/tags/axios-observable"
          }
        ],
        "readingTime": 11.26,
        "hasTruncateMarker": true,
        "authors": [],
        "frontMatter": {
          "title": "vite-react-extension",
          "date": "2022-11-16 12:00:12 +0800",
          "tags": [
            "vite",
            "react",
            "sass",
            "tailwindcss",
            "redux",
            "redux-observable",
            "rxjs",
            "observable-hooks",
            "axios-observable"
          ]
        },
        "nextItem": {
          "title": "MTB Hopper Lite",
          "permalink": "/blog/2022/11/10/mtb-hopper-ramp-lite"
        }
      },
      "content": "繼上一次[vite-react範本設定](/blog/2022/11/08/build-project-react-with-vite)\n\n這次要來擴充這個範本\n\n作成我工作上習慣的配置環境\n\n<!--truncate-->\n\n## extension\n+ sass / tailwindcss 3 / postcss\n+ rxjs / observable-hooks\n+ redux-toolkit\n+ redux-observable / axios-observable\n+ husky\n\n首先拉上一次建好的範本再另外做一個擴充版本的範本\n\n```bash\n$ npx degit sayaku/reactSample viteReactTemplate\n```\n\n下載後進到資料夾\n\n```bash\n$ cd viteReactTemplate\n```\n\n## install sass / tailwindcss 3 / postcss\n\n首先安裝跟tailwindcss相關的依賴\n\n```bash\n$ yarn add sass tailwindcss postcss autoprefixer --dev\n```\n\n裝完後初始化tailwindcss與postcss的設定檔\n\n```bash\n$ npx tailwindcss init -p\n```\n這時目錄下會多兩個設定檔<code>postcss.config.cjs</code>, <code>tailwindcss.config.cjs</code>出來\n\n![](images/01.png)\n\n兩個檔案需要變動如下\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs>\n<TabItem value=\"postcss.config\" label=\"postcss.config.cjs\">\n\n```js\nmodule.exports= {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n\n```\n\n</TabItem>\n\n<TabItem value=\"tailwindcss.config\" label=\"tailwindcss.config.cjs\">\n\n```js {2-5}\nmodule.exports= {\n  mode: \"jit\", // 開啟jit模式可以用自訂數字來定義寬高或間距\n  content: [\n    \"./index.html\",\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n```\n\n</TabItem>\n</Tabs>\n\nvite預設會去找有沒有符合postcss-load-config的檔案並且去套用它\n\n符合postcss-load-config檔名與副檔名可參考:[這裡](https://github.com/postcss/postcss-load-config#postcssrcjs-or-postcssconfigjs)\n\npostcss的config裡關於tailwindcss如果沒特別設定,預設會去抓<code>tailwindcss.config</code>\n\n也就是我們把vite給run起來的時候就會一起去跑postcss與tailwindcss的設定了\n\nvite設定真的少很多（望向webpack還要寫一堆loader...）\n\n預處理css的部分\n\nvite預設有支援sass, 不用另外像webpack來裝sass的loader, 但vite要另外裝sass的依賴（所以我們上面先裝過sass了）\n\n就算你不用sass, vite也預設支援<code>postcss-import</code>與<code>postcss-nesting</code>\n\n讓你可以在css上import其他css以及在css裡面像sass那樣能寫巢狀css\n\n這邊我們先去引入基本的tailwindcss\n\n然後在<code>App.tsx</code>做一些class的修改(套用tailwindcss class)\n\n<Tabs>\n<TabItem value=\"tailwind\" label=\"/src/style/tailwind.scss\">\n\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n</TabItem>\n\n<TabItem value=\"index\" label=\"src/index.scss\">\n\n```css\n@import 'style/tailwind';\n\n```\n\n</TabItem>\n\n<TabItem value=\"app\" label=\"src/App.tsx\">\n\n```tsx {7-19}\nimport { useState } from \"react\";\nimport reactLogo from \"./assets/react.svg\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div className=\"flex flex-col\">\n      <div className=\"w-full flex justify-around p-10\">\n        <a href=\"https://vitejs.dev\" target=\"_blank\" className=\"basis-1/4\">\n          <img src=\"/vite.svg\" className=\"w-full aspect-square\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://reactjs.org\" target=\"_blank\" className=\"basis-1/4\">\n          <img src={reactLogo} className=\"w-full aspect-square\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1 className=\"self-center text-lg mx-5\">Vite + React + Tailwindcss</h1>\n    </div>\n  );\n}\n\nexport default App;\n\n```\n\n</TabItem>\n</Tabs>\n\n接下來正式跑一下\n\n```bash\n$ yarn run dev\n```\n\n跑起來發現我們的tailwindcss都套用上去了\n\n![](images/02.png)\n\n到這邊基本的style的部分都設定好了\n\n## rxjs / observable-hooks\n\n雖然簡單的非同步用Promise/async/await即可達成\n\n但因為我原本使用Angular, 用習慣rxjs\n\n不用rx來寫整個渾身不對勁\n\n所以打算直接在react上使用rx\n\n不得不說剛接觸react-hooks時還一時不知怎麼在hook上使用rx\n\n直到使用observable-hooks後才了解原來rx是這樣寫hooks的\n\n而後來發現react自己本身的hooks有些缺陷可以透過rx來解決\n\n舉個例子好了,在useEffect裡的deps發生變動會觸發useEffect callback\n\n但useEffect callback裡面你會知道是哪個deps發生改變嗎？(還是能做到但是沒那麼直覺)\n\n這個例子使用observable-hooks就方便許多\n\n所以我在使用react-hooks的原則就是能用原生hooks就使用原生的\n\n比較複雜的狀態控制才會使用observable-hooks\n\n接下來就開始裝observable-hooks rxjs\n\n```bash\n$yarn add observable-hooks rxjs\n```\n\n如何使用請參考[官網](https://observable-hooks.js.org/guide/#usage)範例（懂的就知道怎麼用了）\n\n## redux-toolkit\n\n接下來就是做全域狀態管理\n\n我們都熟悉使用redux, 但寫起來實在是很麻煩\n\n所以我們用redux-toolkit來簡化寫redux的流程\n\n首先安裝\n\n```bash\n$yarn add @reduxjs/toolkit react-redux\n```\n\n建立slice, 這裡面同時包含init state, action, reducer\n\n專案上是否要把action, reducer或是epic分檔案寫可由團隊決定\n\n新增資料夾與檔案如下\n\n<Tabs>\n<TabItem value=\"todo.slice.ts\" label=\"store/slices/todo.slice.ts\">\n\n```ts\nimport { createAction, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\n\nconst initialState: { count: number; name: string } = {\n  count: 0,\n  name: \"sayaku\",\n};\n\n// Actions\nexport const increment = createAction<number>(\"todo/INCREMENT\");\nexport const decrement = createAction<number>(\"todo/DECREMENT\");\n\n/**\n * Slice\n */\nexport const todoSlice = createSlice({\n  name: \"todo\",\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(increment, (state, action: PayloadAction<number>) => {\n        return {\n          ...state,\n          count: state.count + action.payload,\n        };\n      })\n      .addCase(decrement, (state, action: PayloadAction<number>) => {\n        return {\n          ...state,\n          count: state.count - action.payload,\n        };\n      });\n  },\n});\n\n\n/**\n * Reducer\n */\n export default todoSlice.reducer;\n\n\n\n```\n\n</TabItem>\n\n<TabItem value=\"reducer.ts\" label=\"store/reducer.ts\">\n\n```ts\nimport { combineReducers } from '@reduxjs/toolkit';\nimport todoReducer from './slices/todo.slice';\n\n\nconst rootReducer = combineReducers({\n  todoStore: todoReducer\n});\n\nexport default rootReducer;\n\n```\n\n</TabItem>\n\n<TabItem value=\"store.config.ts\" label=\"store/store.config.ts\">\n\n```ts\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './reducers';\n\n// 透過 configureStore() 建立 Redux Store\nexport const store = configureStore({\n  reducer: rootReducer,\n});\n\n// type definition\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n\n\n```\n\n</TabItem>\n\n<TabItem value=\"main.tsx\" label=\"main.tsx\">\n\n```tsx {5,6,10,12}\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.scss\";\nimport { store } from \"./store/store.config\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement).render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>\n);\n\n\n```\n\n</TabItem>\n</Tabs>\n\n基礎設定好以後\n\n可以開始使用了\n\n下面簡單使用如何從store拿值\n\n以及透過Observable-hooks實現在hooks裡使用rx與狀態管理\n\n```tsx title=App.tsx {1-9,12-17,38-45}\nimport {\n  useObservable,\n  useObservableState,\n} from \"observable-hooks\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { map } from \"rxjs\";\nimport reactLogo from \"./assets/react.svg\";\nimport { decrement, increment } from \"./store/slices/todo.slice\";\nimport { RootState } from \"./store/store.config\";\n\nfunction App() {\n  const count = useSelector((state: RootState) => state.todoStore.count);\n  const dispatch = useDispatch();\n  // 當store的count變動時透過rx去對count做處理,這邊的範例是當count變動時將count乘以2\n  const twiceCount = useObservableState(\n    useObservable((obs$) => obs$.pipe(map(([v]) => v * 2)), [count])\n  );\n\n  return (\n    <div className=\"flex flex-col\">\n      <div className=\"w-full flex justify-around p-10\">\n        <a href=\"https://vitejs.dev\" target=\"_blank\" className=\"basis-1/4\">\n          <img\n            src=\"/vite.svg\"\n            className=\"w-full aspect-square\"\n            alt=\"Vite logo\"\n          />\n        </a>\n        <a href=\"https://reactjs.org\" target=\"_blank\" className=\"basis-1/4\">\n          <img\n            src={reactLogo}\n            className=\"w-full aspect-square\"\n            alt=\"React logo\"\n          />\n        </a>\n      </div>\n      <h1 className=\"self-center text-lg mx-5\">Vite + React + Tailwindcss</h1>\n      <div className=\"w-full flex justify-around p-10\">\n        <div>count: {count}</div>\n        <div>twiceCount: {twiceCount}</div>\n      </div>\n      <div className=\"w-full flex justify-around p-10\">\n        <button className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" onClick={() => dispatch(increment(1))}>increment</button>\n        <button className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" onClick={() => dispatch(decrement(1))}>decrement</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n```\nrun起來後應該會長這樣, 可以正常運作\n\n![](./images/03.png)\n\n## redux-observable / axios-observable\n\n現在專案裡的Redux都是做同步處理\n\n如果今天要加入打API等非同步處理雖然可以透過redux-toolkit裡的createAsyncThunk\n\n但我們既然都使用rx了, 就統一都使用rx來串接非同步這塊\n\n畢竟非同步就是rx的強項\n\n當然你也可以在createAsyncThunk裡面使用rx\n\n但我實在不喜歡使用rx還要在那邊轉成promise還有async/await\n\n所以這邊透過Redux Middleware來處理非同步這一塊\n\n而Middleware我們使用redux-observable來處理非同步\n\n首先安裝redux-observable\n\n```bash\n$yarn add redux-observable -D\n```\n\n之後新增與修改下列檔案\n\n\n<Tabs>\n<TabItem value=\"todo.slice.ts-2\" label=\"store/slices/todo.slice.ts\">\n\n```ts {3,13,16,19-25}\nimport { createAction, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { filter, map, mergeMap } from \"rxjs\";\nimport { AppEpic } from \"../store.config\";\n\nconst initialState: { count: number; name: string } = {\n  count: 0,\n  name: \"sayaku\",\n};\n\n// Actions\nexport const increment = createAction<number>(\"todo/INCREMENT\");\nexport const decrement = createAction<number>(\"todo/DECREMENT\");\nexport const updateName = createAction<string>(\"todo/UPDATE_NAME\");\n\n// Async Actions\nexport const fetchData = createAction<undefined>(\"todo/FETCH_DATA\");\n\n// Epics\nexport const fetchUserEpic: AppEpic = (action$, store, { getUserName }) =>\n  action$.pipe(\n    filter(fetchData.match),\n    mergeMap((action) =>\n      getUserName().pipe(map((response) => updateName(response.name)))\n    )\n  );\n\n/**\n * Slice\n */\nexport const todoSlice = createSlice({\n  name: \"todo\",\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(increment, (state, action: PayloadAction<number>) => {\n        return {\n          ...state,\n          count: state.count + action.payload,\n        };\n      })\n      .addCase(decrement, (state, action: PayloadAction<number>) => {\n        return {\n          ...state,\n          count: state.count - action.payload,\n        };\n      })\n      .addCase(updateName, (state, action: PayloadAction<string>) => {\n        return {\n          ...state,\n          name: action.payload,\n        };\n      });\n  },\n});\n\n/**\n * Reducer\n */\nexport default todoSlice.reducer;\n\n```\n\n</TabItem>\n\n<TabItem value=\"epics\" label=\"store/epics.ts\">\n\n```ts\nimport { combineEpics } from \"redux-observable\";\nimport { fetchUserEpic as TodoFetchUserEpic } from \"./slices/todo.slice\";\n\nexport const rootEpic = combineEpics(TodoFetchUserEpic);\n\n\n```\n\n</TabItem>\n\n<TabItem value=\"fakeApi\" label=\"store/fakeApi.ts\">\n\n```ts\nimport { map, timer } from \"rxjs\";\n\nexport const fakeApi = {\n  getUserName: () =>\n    timer(2000).pipe(map(() => ({ name: \"Monica\" }))),\n};\n\n```\n\n</TabItem>\n\n<TabItem value=\"store-config\" label=\"store/store.config.ts\">\n\n```ts\nimport { fakeApi } from \"./fakeApi\";\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport rootReducer from \"./reducers\";\nimport { createEpicMiddleware, Epic } from \"redux-observable\";\nimport { Action } from \"@reduxjs/toolkit\";\nimport { rootEpic } from \"./epics\";\n\n// type definition\nexport type AppState = ReturnType<typeof rootReducer>; // for useSelector\nexport type AppDispatch = typeof store.dispatch;\nexport type AppEpic = Epic<Action, Action, AppState, typeof fakeApi>;\n\nexport const epicMiddleware = createEpicMiddleware<\n  Action,\n  Action,\n  AppState,\n  typeof fakeApi\n>({\n  dependencies: fakeApi,\n});\n\n// 透過 configureStore() 建立 Redux Store\nexport const store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) => [\n    ...getDefaultMiddleware(),\n    epicMiddleware,\n  ],\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\n\n// epicMiddleware執行必須要在初始store之後\nepicMiddleware.run(rootEpic);\n\n\n```\n\n</TabItem>\n</Tabs>\n\n在Redux裡面的Middleware執行點是Dispatch Action後與進到Reducer之前\n\n所以非同步的動作我們都會在Middleware裡面實作\n\n我們這邊非同步使用redux-observable裡的Epic\n\n這個如果在Angular上使用的ngrx裡是相當於effect的角色\n\n特點在於Action in Action out\n\n他的生命週期大概是這樣\n\n![](./images/04.png)\n\n回到<code>App.tsx</code>這邊做修改\n\n```tsx {10, 19-29}\nimport { useObservable, useObservableState } from \"observable-hooks\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { map } from \"rxjs\";\nimport reactLogo from \"./assets/react.svg\";\nimport { decrement, fetchData, increment } from \"./store/slices/todo.slice\";\nimport { RootState } from \"./store/store.config\";\n\nfunction App() {\n  const count = useSelector((state: RootState) => state.todoStore.count);\n  const name = useSelector((state: RootState) => state.todoStore.name);\n  const dispatch = useDispatch();\n  const twiceCount = useObservableState(\n    useObservable((obs$) => obs$.pipe(map(([v]) => v * 2)), [count])\n  );\n\n  return (\n    <div className=\"flex flex-col\">\n      ...\n      <div className=\"w-full flex justify-around p-10\">\n        <button\n          className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n          onClick={() => dispatch(fetchData())}\n        >\n          launch api\n        </button>\n\n        <div>name: {name}</div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n```\n\n這邊就完成redux裡打Api等非同步處理的動作了\n\n在畫面上按下launch api, 兩秒後會更新store, 預期會看到name從sayaku換成monica\n\n這邊我們的api是做假的\n\n而實際上真實要打Api我會另外使用axios\n\naxios-observable則是使用rxjs將axios包裝起來\n\n同時也能做攔截器\n\n是個很方便的套件\n\n一樣也是把它裝起來\n\n```bash\n$yarn add axios axios-observable\n```"
    },
    {
      "id": "/2022/11/10/mtb-hopper-ramp-lite",
      "metadata": {
        "permalink": "/blog/2022/11/10/mtb-hopper-ramp-lite",
        "editUrl": "https://github.com/sayaku/sayaku.github.io/edit/main/blog/2022-11-10-mtb-hopper-ramp-lite/index.md",
        "source": "@site/blog/2022-11-10-mtb-hopper-ramp-lite/index.md",
        "title": "MTB Hopper Lite",
        "description": "網路上看到這個有趣的產品- MTB HOPPER",
        "date": "2022-11-10T16:00:12.000Z",
        "formattedDate": "2022年11月10日",
        "tags": [
          {
            "label": "mtb",
            "permalink": "/blog/tags/mtb"
          },
          {
            "label": "mtb-hopper",
            "permalink": "/blog/tags/mtb-hopper"
          }
        ],
        "readingTime": 3.415,
        "hasTruncateMarker": true,
        "authors": [],
        "frontMatter": {
          "title": "MTB Hopper Lite",
          "date": "2022-11-10 16:00:12 +0800",
          "tags": [
            "mtb",
            "mtb-hopper"
          ]
        },
        "prevItem": {
          "title": "vite-react-extension",
          "permalink": "/blog/2022/11/16/vite-react-extension"
        },
        "nextItem": {
          "title": "vite+react+typescript+prettier+eslint",
          "permalink": "/blog/2022/11/08/build-project-react-with-vite"
        }
      },
      "content": "![](images/cover.jpeg)\n\n網路上看到這個有趣的產品- MTB HOPPER\n\n簡單來說就是個可以簡易組合拆裝方便攜帶的行動跳台\n\n實際操作網路上搜尋MTB HOPPER應該會有一堆範例影片\n\n這邊主要紀錄他怎麼組合與收納\n<!--truncate-->\n## Unboxing / Assembly\n![](images/01.png)\n\n送來時就是個簡單的紙箱\n\n![](images/02.png)\n\n開箱內容就是一張很簡單的說明書\n\n內容官網有一份pdf可供[下載](https://cdn.shopify.com/s/files/1/2484/8112/files/LITE.pdf?v=1613927342)\n\n![](images/03.png)\n\n拿出來就像一個小公事包\n\n重量約五公斤\n\n另一面有雙肩背帶\n\n騎MTB背個5KG應該沒啥問題\n\n公事包打開後會有這些零件\n\n![](images/04.png)\n\n基本上非常好組\n\n不用看說明書慢慢摸索都知道怎麼組\n\n零件上面也有對應接合的編號\n\n按照號碼接起來基本上不會接錯\n\n接好以後就是個跳台的樣子\n\n這個跳台可以調高度\n\n最低的高度就是長這個樣子\n\n![](images/05.png)\n\n\n這樣看好像還好\n\n等你真的騎上車往跳台看過去會覺得\n\n媽呀這好像有點高有點陡\n\n我承認第一次跳真的要克服恐懼\n\n什麼跳台要領: 平衡, 蹲低, 起跳\n\n早就忘了...\n\n記得重心不要往前面，不然起跳後腳會被彈飛（第一次跳台不知道就是這樣飛出去的）\n\n所以才買這個產品來練跳台\n\n起跳時重心會在後輪上, 屁股位置應該會在後輪軸心的正上方（官網建議的）\n\n多跳幾次好像就抓到要領了\n\n<iframe width=\"320\" height=\"560\" src=\"https://www.youtube.com/embed/OtP-bDZb22Q\" title=\"November 16, 2022\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n\n慢動作\n\n<iframe width=\"320\" height=\"560\" src=\"https://www.youtube.com/embed/Iv9SkHC57vo\" title=\"November 16, 2022\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## Disassembly / Fold\n\n其實會裝就會拆\n\n問題是拆了以後我忘記當初是怎麼放的\n\n這邊記錄一下\n\n中間兩片支架放最下面\n\n然後兩個側腳折起來交疊\n\n最後是正面可調高度的大腳放最上面\n\n![](images/06.png)\n\n這樣就可以完整收合\n\n![](images/07.png)\n\n那要怎麼固定收合呢？\n\n當初這邊卡關卡超久\n\n原來是上方那一條繩子拉到那個洞洞卡住就完成固定了\n\n看下面分解圖\n\n![](images/09.png)\n\n![](images/10.png)\n\n兩邊都做一樣的動作\n\n這樣就完成固定了\n\n\n完成！！這是有雙肩背帶的那一面\n\n一樣也是可以調背帶鬆緊\n\n![](images/11.jpeg)\n\n這個跳台整體來說真的設計得很棒\n\n可攜式跳台真是一大誘因\n\n背著騎到哪就能組跳台玩飛跳\n\nyoutube上有展示此跳台的很多應用\n\n有看到拿去玩街攀的各種誇張技巧\n\n![](images/cover2.jpg)"
    },
    {
      "id": "/2022/11/08/build-project-react-with-vite",
      "metadata": {
        "permalink": "/blog/2022/11/08/build-project-react-with-vite",
        "editUrl": "https://github.com/sayaku/sayaku.github.io/edit/main/blog/2022-11-08-build-project-react-with-vite/index.md",
        "source": "@site/blog/2022-11-08-build-project-react-with-vite/index.md",
        "title": "vite+react+typescript+prettier+eslint",
        "description": "每次要寫一個新的專案都要重新設定一次環境",
        "date": "2022-11-08T10:00:12.000Z",
        "formattedDate": "2022年11月8日",
        "tags": [
          {
            "label": "vite",
            "permalink": "/blog/tags/vite"
          },
          {
            "label": "react",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 7.97,
        "hasTruncateMarker": true,
        "authors": [],
        "frontMatter": {
          "title": "vite+react+typescript+prettier+eslint",
          "date": "2022-11-08 10:00:12 +0800",
          "tags": [
            "vite",
            "react"
          ]
        },
        "prevItem": {
          "title": "MTB Hopper Lite",
          "permalink": "/blog/2022/11/10/mtb-hopper-ramp-lite"
        },
        "nextItem": {
          "title": "Study: Refactoring - Encapsulate",
          "permalink": "/blog/2020/07/27/study-refactoring"
        }
      },
      "content": "每次要寫一個新的專案都要重新設定一次環境\n\n久了也是很煩\n\n不如寫一個範本模板來使用\n\n這次試著建立搭配vite的react專案模板\n\n<!--truncate-->\n\n## Install vite/react/typescript\n按照官網起手式\n\n``` bash\n$ yarn create vite\n```\n安裝過程中會問你\n\n1. 專案名稱,名稱就先叫reactSample吧\n2. 要搭配哪個前端框架\n3. 要選用js還是ts\n\n\n![](images/01.png)\n\n如果你不想那麼囉唆也可以下以下指令\n\n```bash\n$ yarn create vite reactSample --template react-ts\n```\n\n之後會建構一個名為reactSample的資料夾，資料夾結構如下\n\n![](images/02.png)\n\n看得出來還沒安裝依賴的node_modules\n\n裝一下(記得要先進到剛剛創建好的reactSample目錄裡)\n\n```bash\n$ cd reactSample && yarn install\n```\n恩！\n\n到目前為止vite/react/typescript都已經裝好了\n\n可以簡單的測試\n\n```bash\n$ yarn run dev\n```\n\n恩！正常作動！！\n\n![](images/20.png)\n\n\n接下來裝開發時需要的靜態檢查工具\n\n## Install Eslint\n\n靜態檢查工具可以在開發階段就先檢測出你的程式碼是否有簡單邏輯或是格式甚至於拼字上的錯誤\n\ntypescript有tslint的靜態檢查工具, 但功能跟eslint大同小異\n\n後來靜態檢查功能就跟eslint合併然後tslint就被棄用了（幫QQ）\n\n那我們來裝eslint吧\n\n```bash\n$ yarn add -D eslint\n```\n配置初始設定文件檔\n\n```bash\n$ npx eslint --init\n```\n過程中過程中安裝小幫手會問幾個選項\n\n![](images/03.png)\n\n選第二項<code>To check syntax and find problems</code>\n\n我們晚點會使用prettier來強制執行這個設定\n\n![](images/04.png)\n\n我們用react+typescript那當然就是選第一個囉\n\n![](images/05.png)\n\n這邊會問你以下這些依賴套件要一起安裝,你是否要一起安裝？\n\n但因為這邊安裝的套件是使用NPM,我們使用的是yarn,所以先選擇<code>NO</code>\n\n改用下面yarn的寫法\n```bash\n$ yarn add -D eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest\n```\n基本上你的基礎eslint設定檔已經建出來了\n\n![](images/06.png)\n\n對了！在上面小幫手設定過程中他會問你設定檔要用什麼格式,可以自己習慣用什麼格式而定\n\n我這邊是用<code>json</code>, 所以產出一個<code>.eslintrc.json</code>的檔案\n\n接著安裝一些依賴套件讓eslint跟typescript關聯\n\n```bash\n$ yarn add -D eslint-plugin-import @typescript-eslint/parser eslint-import-resolver-typescript\n```\n\n## Install Prettier\n\nPrettier是一個程式碼格式化的套件\n\n本身並不像Eslint去執行靜態檢查\n\n我們code寫久了常常縮排跑掉或是括號少個空格等等\n\n尤其是團隊寫code時大家寫的風格不一樣,看起來就很難閱讀\n\n所以有個可以統一風格的工具是很重要的\n\n所以廢話不多說\n\n直接安裝相關的套件\n\n```bash\n$ yarn add -D prettier eslint-config-prettier eslint-plugin- prettier eslint-plugin-react-hooks\n```\n\n裝完後新增一個空白的prettier設定檔<code>.prettierrc</code>\n\n```bash\n$ touch .prettierrc\n```\n\n如下圖\n\n![](images/07.png)\n\n再來是vscode也要安裝相關插件,這樣有錯誤時才會幫你高亮出來ＸＤ\n\n插件百百種\n\n我自己是用星星數最多的拉\n\n![](images/16.png)\n\n裝完啟用後應該在資訊列會有prettier的圖示選項\n\n![](images/17.png)\n\n## eslintrc setting\n\n創建完<code>.prettierrc</code>後可以來設定eslintrc擴充部分\n\n在extends部分添加prettier\n\n![](images/08.png)\n\n關於eslint的rules的部分\n\n通常是根據團隊的習慣自己去制定\n\n[可以參考相關eslint的規則](https://eslint.org/docs/latest/rules/)\n\n在plugin的部分也記得要添加prettier相關的插件\n\n![](images/09.png)\n\n最後一個設定是設定typescript的import解析器\n\n![](images/10.png)\n\n這樣就差不多設定完了\n\n可以來測試一下\n\n我們在<code>package.json</code>的script增加幾個指令\n\n![](images/11.png)\n\n設定完後\n\n隨便在任何一隻檔案裡面添加一個明顯不會通過規則的錯誤\n\n例如我在App.tsx新增一個<code>let a= 0</code>\n\n![](images/12.png)\n\n其實在寫的當下編輯器已經出現紅色毛毛蟲警告你這邊會有問題了\n\n但這邊先不理他\n\n接著我們打指令\n\n```bash\n$ yarn run lint\n```\n\n這時eslint就會告訴你哪個檔案哪一行的程式碼沒有通過驗證\n\n![](images/13.png)\n\n當然eslint也會提示你可以使用<code>--fix</code>參數\n\n來自動幫你修正錯誤\n\n可以試著執行剛剛在package.json裡的script另外新增的<code>lint:fix</code>\n\n```bash\n$ yarn run lint:fix\n```\n會發現eslint會幫你根據規則把錯誤修復\n\n![](images/14.png)\n\n但原則上這功能還是少用, 因為還是自己手動看錯誤自己改才比較踏實\n\n## eslintignore\n\n這時候還能再另外設定哪些檔案不想被檢查\n\n可以另外創建<code>.eslintignore</code>\n\n```bash\n$ touch .eslintignore\n```\n像是如果剛剛的App.tsx不想被檢查的話\n\n可以直接寫\n\n![](images/15.png)\n\n這樣eslint就會略過不檢查這個檔案\n\n## prettier setting\n\nprettier設定的部分\n\n可以根據團隊使用習慣在<code>.prettierrc</code>加上規則\n\n規則的部分可以參考官網:[點我](https://prettier.io/playground/)\n\n我自己的設定是這樣拉\n\n```json\n{\n  \"semi\": true,\n  \"tabWidth\": 4,\n  \"printWidth\": 100,\n  \"singleQuote\": true,\n  \"trailingComma\": \"all\",\n  \"jsxSingleQuote\": true,\n  \"bracketSpacing\": true\n}\n```\n\n接下來做測試\n\n隨便拿個檔案這次找<code>main.tsx</code>\n\n刻意把裡面的格式打亂然後縮排亂凸\n\n![](images/18.png)\n\n這時候按下鍵盤<code>shift</code>+<code>alt</code>+<code>F</code>\n\nmacOS請用<code>⇧Shift</code>+<code>⌥Option</code>+<code>F</code>\n\n![](images/19.png)\n\n你會看到prettier幫你把縮排縮好,遺失的句尾分號也補上去了\n\n## 製作範本\n使用[degit](https://github.com/Rich-Harris/degit)這樣的工具\n\n只要github上的repo都可以當成範本,當然其他的gitlab之類的repo也可\n\n以往我們可能會用clone來搭建項目的範本,但往往我們不需要它裡面的git紀錄\n\n現在可以很單純的使用degit來拉我們想的範本快速搭建專案骨架\n\n使用方法\n\n```bash\n$ npx degit [template repository]#[branch|tag|commit hash] [your_new_proj]\n```\n＃號後面接的可以是分支名或tag或commit\n\n不寫的話預設是master | main 分支\n\n例如我剛剛推上去的reactSample就可以當成template\n\n可以寫成\n\n```bash\n$ npx degit sayaku/reactSample new_react_project\n```\n\n或是網址\n\n```bash\n$ npx degit https://github.com/sayaku/reactSample new_react_project\n```\n這樣就可以快速把我原本寫好的範本拿來開新的專案了\n\n其實我這篇寫了這麼多\n\n在社群裡面早就有人寫了很實用的template可以直接當專案範本了\n\n可以參考[Awesome Vite.js](https://github.com/vitejs/awesome-vite#templates)\n\n\n## Refs \n\n[vite](https://vitejs.dev/) \n\n[ESLint + Prettier + Typescript and React in 2022](https://blog.devgenius.io/eslint-prettier-typescript-and-react-in-2022-e5021ebca2b1) \n\n[Awesome Vite.js](https://github.com/vitejs/awesome-vite#templates)"
    },
    {
      "id": "/2020/07/27/study-refactoring",
      "metadata": {
        "permalink": "/blog/2020/07/27/study-refactoring",
        "editUrl": "https://github.com/sayaku/sayaku.github.io/edit/main/blog/2020-07-27-study-refactoring/index.md",
        "source": "@site/blog/2020-07-27-study-refactoring/index.md",
        "title": "Study: Refactoring - Encapsulate",
        "description": "讀書會內容-第七節：Encapsulate（封裝）",
        "date": "2020-07-27T18:58:57.000Z",
        "formattedDate": "2020年7月27日",
        "tags": [],
        "readingTime": 5.685,
        "hasTruncateMarker": true,
        "authors": [],
        "frontMatter": {
          "title": "Study: Refactoring - Encapsulate",
          "date": "2020-07-27 18:58:57 +0800"
        },
        "prevItem": {
          "title": "vite+react+typescript+prettier+eslint",
          "permalink": "/blog/2022/11/08/build-project-react-with-vite"
        },
        "nextItem": {
          "title": "2019-Mt.富士ヒルクライムに挑戦！",
          "permalink": "/blog/2019/09/20/fujisan-ni-nobotta"
        }
      },
      "content": "讀書會內容-第七節：Encapsulate（封裝）  \n該章節提到重構的封裝有以下9種方法  \n<!--truncate-->\n[Encapsulate Record (封裝紀錄)](#EncapsilateRecord)  \n[Encapsulate Collection (封裝集合)](#EncapsulateCollection)  \n[Replace Primitive with Object (將基本元素轉換成物件)](#ReplacePrimitivewithObject)   \n[Replace Temp with Query (將暫時變數轉換成查詢函式)](#ReplaceTempwithQuery)    \n[Extract Class (提取類別) ](#ExtractClass)   \n[Inline Class (內聯類別)](#InlineClass)   \n[Hide Delegate (隱藏委託)](#HideDelegate)   \n[Remove Middle Man (移除中間人)](#RemoveMiddleMan)   \n[Substitute Algorithm (替換演算法)](#SubstituteAlgorithm)   \n\n\n\n## Encapsilate Record (封裝紀錄)<a name=\"EncapsilateRecord\"></a>\n\n\nbefore\n\n``` javascript\n    organization = {name: 'sayaku', country: 'Taiwan'};\n```\n\nafter\n``` javascript\n    class Organization {\n        constructor(data){\n            this._name= data.name;\n            this._country= data.country;\n        }\n\n        get name(){return this._name;}\n        set name(arg){this._name=arg;}\n        get country(){this._country;}\n        set country(arg){this._country=arg;}\n    }\n```\n\n說明：  \n1. 用class包裝紀錄變數，並且定義存取的getter, setter  \n2. getter回傳原本資料的深副本而不是回傳原始紀錄  \n3. 重構時注重setter更新的部分  \n4. 自定義更語意化的函式  \n\n## Encapsulate Collection (封裝集合)<a name=\"EncapsulateCollection\"></a>\n\nbefore\n\n``` javascript\n    class Person {\n        get courses() { return this._courses;}\n        set courses(aList) { this._courses=aList;}\n    }\n```\n\nafter\n\n``` javascript\n    class Person {\n        get courses() { return this._courses.slice();}\n        addCourse(aCourse) { ... }\n        removeCourse(aCourse) { ... }\n    }\n```\n\n說明：  \n1. 與前面Encapsilate Record 概念相同，但封裝的對象是集合  \n2. 新增對集合操作（ＣＲＵＤ新增查詢修改移除）的函式  \n3. 返回集合使用代理或是副本  \n\n## Replace Primitive with Object (將基本元素轉換成物件)<a name=\"ReplacePrimitivewithObject\"></a>\n\n\nbefore\n``` javascript\n    order.filter(o = 'high' === o.priority || 'rush' === o.priority);\n```\n\nafter\n``` javascript\n    order.filter(o = o.priority.higherThan(new Priority('normal')));\n```\n\n說明：  \n1. 對物件的屬性轉換成用物件的形式表示  \n2. 語意化getter,setter函式取個不易讓人誤解的名稱,例如：回傳的值是toString()而不是原本預期的屬性,那函式名稱建議在後綴加上toString,語意上比較上是索取字串而不是原本的屬性  \n3. 讓程式碼更清楚的表達目的  \n\n\n## Replace Temp with Query (將暫時變數轉換成查詢函式)<a name=\"ReplaceTempwithQuery\"></a>\n\nbefore\n``` javascript\n    const basePrice = this.quantity * this._itemPrice;\n\n    if (basePrice > 1000)\n        return basePeice * .95;\n    else\n        return basePrice * .98;\n```\n\nafter\n``` javascript\n    get basePrice() { this.quantity * this._itemPrice;}\n    ...\n    if (basePrice > 1000)\n        return basePeice * .95;\n    else\n        return basePrice * .98;\n\n```\n\n說明：  \n1. 暫時的變數可以儲存某些程式碼的值，將之語意化為唯讀函式  \n2. 確定該變數被使用時不會產生不同的值，也就是最初他只會被賦值一次  \n\n## Extract Class (提取類別) <a name=\"ExtractClass\"></a>\n\nbefore\n``` javascript\n    class Person {\n        get officeAreaCode() {return this._officeAreaCode;}\n        get officeNumber() {return this._officeNumber;}\n    }\n```\n\nafter\n``` javascript\n    class Person {\n        get officeAreaCode() {return this._telephoneNumber.areaCode;}\n        get officeNumber() {return this._telephoneNumber.number;}\n    }\n\n    class Telephone {\n        get areaCode(){return this._areaCode;}\n        get number(){return this._number;}\n    }\n```\n\n說明：  \n1. 當類別裡已經複雜到需要拆解功能並分門別類時使用  \n2. 類別必須是個清晰的抽象， 只應該處理一些明確的功能  \n3. 一拆解出來的功能分成一個個子類別，並與父類別產生連結  \n\n## Inline Class (內聯類別)<a name=\"InlineClass\"></a>\n\nbefore\n``` javascript\n\n    class Person {\n        get officeAreaCode() {return this._telephoneNumber.areaCode;}\n        get officeNumber() {return this._telephoneNumber.number;}\n    }\n\n    class Telephone {\n        get areaCode(){return this._areaCode;}\n        get number(){return this._number;}\n    }\n```\n\nafter\n``` javascript\n    class Person {\n        get officeAreaCode() {return this._officeAreaCode;}\n        get officeNumber() {return this._officeNumber;}\n    }\n```\n\n說明：  \n1. 是Extract Class (提取類別)的反向操作  \n2. 遇到沒什麼用途且不該存在的子類別，使用inline class合併之  \n3. 通常是用於重構後，功能被拆分後移除沒用子類別的實作  \n\n## Hide Delegate (隱藏委託)<a name=\"HideDelegate\"></a>\n\nbefore\n``` javascript\n    manager = aPerson.department.manager;\n```\n\nafter\n``` javascript\n    manager = aPerson.manager;\n\n    class Person {\n        get manager(){return this.depaetment.manager;}\n    }\n```\n\n說明：  \n1. 封裝用意是隱藏不需要被模組知道系統的其他部分  \n2. 其實就是隱藏欄位，減少系統內部透明度  \n3. 將委託的方法封裝起來，達成隱藏委託  \n\n## Remove Middle Man (移除中間人)<a name=\"RemoveMiddleMan\"></a>\nbefore\n``` javascript\n    manager = aPerson.manager;\n\n    class Person {\n        get manager(){return this.depaetment.manager;}\n    }\n```\nafter\n``` javascript\n    manager = aPerson.department.manager;\n```\n\n說明：  \n1. 該模式是Hide Delegate (隱藏委託)的逆向操作  \n2. 當委託方法越來越多，會發現每新增一個委託方法就要多一個轉傳機制，\n方法一多便難以管理,故可以逆向操作使用移除中間人模式來重構  \n\n\n## Substitute Algorithm (替換演算法)<a name=\"SubstituteAlgorithm\"></a>\nbefore\n``` javascript\n    function foundPerson (people) {\n        for (let i=0; i< people.length; i++){\n            if(people[i] === 'Don'){\n                return 'Don';\n            }\n\n            if(people[i] === 'John'){\n                return 'John';\n            }\n\n            if(people[i] === 'Sayaku'){\n                return 'Sayaku';\n            }\n        }\n        return '';\n    }\n```\n\nafter\n``` javascript\n    function foundPerson(people){\n        const candidates = ['Don', 'John', 'Sayaku'];\n        return people.find(p => candidates.includes(p)) || '';\n    }\n```\n\n說明：  \n1. 發現重複且枯燥的方法可以重構成明確易懂的方法時使用  \n2. 困難化作簡單"
    },
    {
      "id": "/2019/09/20/fujisan-ni-nobotta",
      "metadata": {
        "permalink": "/blog/2019/09/20/fujisan-ni-nobotta",
        "editUrl": "https://github.com/sayaku/sayaku.github.io/edit/main/blog/2019-09-20-fujisan-ni-nobotta/index.md",
        "source": "@site/blog/2019-09-20-fujisan-ni-nobotta/index.md",
        "title": "2019-Mt.富士ヒルクライムに挑戦！",
        "description": "每年一次的日本單車旅遊，在同事的慫恿下",
        "date": "2019-09-20T23:56:12.000Z",
        "formattedDate": "2019年9月20日",
        "tags": [],
        "readingTime": 13.48,
        "hasTruncateMarker": true,
        "authors": [],
        "frontMatter": {
          "title": "2019-Mt.富士ヒルクライムに挑戦！",
          "date": "2019-09-20 23:56:12 +0800"
        },
        "prevItem": {
          "title": "Study: Refactoring - Encapsulate",
          "permalink": "/blog/2020/07/27/study-refactoring"
        }
      },
      "content": "![](fujisan/24.jpg)\n每年一次的日本單車旅遊，在同事的慫恿下\n\n這次來體驗看看日本當地的單車挑戰賽\n\n也是台灣車友去日本比賽一定會參加的挑戰賽- Mt.富士ヒルクライム\n\n<font color=\"#7b7b7b\" size=\"2\">話說...太久沒來更新網誌，發現原本的的圖床已經結束營業收掉了...  \n圖片完全沒有備份...幫ＱＱ,懶得重寫...乾脆砍掉文章  \n然後git另開分支重寫Blog</font>\n\n\n<!--truncate-->\n由於之前有環過日本四國，關西地區包含琵琶湖一周(抱歉文章已砍,懶得重寫)\n\n所以帶車去日本騎車的經驗已經算是非常豐富（吹噓貌）\n\n這次因為要參加比賽不是屬於長途旅行，又是第一次帶小綠去日本\n\n所以這次選擇租用單車航空箱，畢竟高價單車碰傷划不來（碰傷大概也沒心情繼續旅程了）\n\n![](fujisan/01.jpg)\n\n大概就這麼大\n\n![](fujisan/02.jpg)\n\n車子裝箱後還有空間順便塞了打氣筒跟車衣車褲還有維修工具\n\n![](fujisan/03.jpg)\n\n接下來帶去機場，一如往常沒過Ｘ光機（但日本的會過）就上拖車了\n\n經過約莫3小時的飛行，人生第二次來到東京成田機場（是的我第二次來東京）\n\n![](fujisan/04.jpg)\n\n本來要直接搭ＪＲ去新宿，後來看到訊息說山手線發生人身事故...只好轉其他交通工具\n\n在第二航廈有直達新宿的巴士（3300円/片道）,單程可以吃食べ放題了...\n\n是說一下飛機就一直下雨，到了新宿也是天氣不美麗\n\n隨手查了食べログ..發現附近有一間分數還不錯高的拉麵\n\n![](fujisan/05.jpg)\n\nはやし田らぁ麺\n\n![](fujisan/06.jpg)\n\n真的好吃啦！！\n\n隔天直接到新宿站搭富士急行的バス\n\n直達河口湖\n\n運氣蠻好，碰到可以塞單車箱的車子，不然聽聞以前的車友常常上不了\n\n抵達河口湖後，還要再拖著笨重的單車箱走2公里到今晚入宿的旅館...\n\n![](fujisan/07.jpg)\n\n旅館是中國人開的，因為現在是河口湖的旺季，真的沒有半年前訂房根本訂不到\n\n感謝這次跟我同行的同事-馬克有訂到這間（雖然走得遠了點）\n\n不然就要睡車站了\n\n![](fujisan/08.jpg)\n\n旅館是傳統和室，たたみ的藺草味很濃很香\n\n行李安置好後下去前庭，旅館主人同意讓我們在這邊組單車\n\n![](fujisan/09.jpg)\n\n組完後準備去會場拿取明天富士山挑戰賽的物資以及號碼布\n\n![](fujisan/10.jpg)\n\n享受一下這短暫的陽光（因為之後幾天在下雨...）\n\n旅館距離會場大概10公里，爬升約300公尺\n\n會場在富士山的山腳下\n\n到現場已經人山人海了\n![](fujisan/11.jpg)\n\n大家車子隨便靠著就去拿物資了\n\n隨便幾台都10萬以上的名車啊...\n\n真不愧是日本人！！\n\n當然也有幾個台灣人組團來比賽\n\n![](fujisan/11-1.jpg)\n\n領了號碼布，這數字不錯！！\n\n![](fujisan/11-2.jpg)\n\n行李送上下山專用袋，你可以騎車時先把外套等行李放裡面\n\n到山頂的時候統一領取（因為今年山頂真的冷）\n\n![](fujisan/11-3.jpg)\n\n會場根本就是單車界大拜拜\n\n拿完物資後天氣還不錯，把握現在的好天氣去繞繞河口湖\n\n![](fujisan/20.jpg)\n\n來到富士御室浅間神社祈禱明天騎乘順利\n\n順便求了御朱印\n\n![](fujisan/19.jpg)\n![](fujisan/18.jpg)\n\n拜完後就逆時針環湖啦！為什麼要逆時針？\n\n因為日本道路靠左行駛，逆時針會離湖比較近\n\n到了河口湖著名拍攝逆富士的景\n\n![](fujisan/13.jpg)\n\n但運氣很不好，富士山被厚厚的雲遮住\n\n其實我這輩子還沒看過富士山的本尊...\n\n不然這個點可以看到富士山時應該是長這樣（取自google街景） \n![](fujisan/13-1.png)\n\n![](fujisan/12.jpg)\n\n陽光灑下來,其實我比較期待雲散開可以看見富士山\n\n![](fujisan/14.jpg)\n![](fujisan/15.jpg)\n\n好吧！看不到就是看不到...\n\n晚餐也不知要吃啥，可能是觀光區的關係\n\n東西都靠杯貴！！\n\n只好隨便找間連鎖店來吃\n\n![](fujisan/17.jpg)\n\n車子停好，剛好遇到一個阿杯台灣人迷路\n\n不會日文的阿杯聽到我們停車時講中文就好像遇到救星\n\n他手機快沒電又與團員失聯\n\n還好同事馬克隨身攜帶充電尿袋應應急順便幫他找他住宿的旅館怎麼走\n\n阿杯為了答謝我們請我們吃晚餐\n\n我也不客氣點了很多（我真的好意思！）\n\n![](fujisan/16.jpg)\n![](fujisan/16-1.jpg)\n\n吃完後我只能說阿杯你真好，你一定會順利找到回去的路的！！\n\n然後明天開心完賽\n\n真的吃得很澎湃就是了XD\n\n吃完回旅館順便去超市帶了一盒宵夜，但手腳太慢搶不到半額\n\n![](fujisan/21.jpg)\n\n此時晚上的河口湖突然開始下起雨來\n\n只好祈禱明天比賽能夠好天氣\n\n但通常會有這種想法\n\n老天爺就會給你下到不要不要的\n\n天剛亮...旅館隔壁幾間似乎也是車友\n\n早早就出門了！\n\n往外看看路面\n\n果然我心中的老天爺沒讓我失望\n\n地是濕的....但沒下雨\n\n很好！就趁這段空擋趕快殺到比賽會場\n\n![](fujisan/22.jpg)\n\n到了會場發現其實我們算很晚到了\n\n連上山行李巴士都已經開上山去了...\n\n其實自己簡章也沒仔細看清楚行李配送時間...怨不得人...\n\n開賽前開始下起雨來，氣溫也變低很多\n\n其實一直搞不懂為何這個比賽要辦在日本的梅雨季呢？\n\n![](fujisan/23.jpg)\n\n表定7:30出發，由於出發人數眾多（聽聞有1萬人）\n\n我被安排在第19梯次出發，差不多8:30才輪到我們\n\n話說我同事馬克的梯次比較前面早我30分鐘出發\n\n其實等到出發的時候身體已經完全冷掉了\n\n![](fujisan/23-1.jpg)\n\n終於輪到我們出發了\n\n富士山挑戰賽\n\n起點由富士北麓公園陸上競技場，到終點富士山五合目（標高2305m）\n\n全長23.4km,總爬升1200m,以難度來說大概就是台灣宜蘭的太平山差不多\n\n環法坡度等級是最高級的ＨＣ級\n\n全程除了補給加水之外就沒有落地了（所以就沒有騎乘過程的照片了）\n\n是說天候惡劣整路起霧下雨根本看不到什麼景色就是了\n\n好不容易在這惡劣又低溫的天候終於騎上終點富士五合目\n\n上面的溫度只有9度，因為下雨又大風體感溫度大概3~4度吧\n\n![](fujisan/23-2.jpg)\n到終點後雨下更大了\n\n![](fujisan/25.jpg)  \n吃個冰淇淋壓壓驚\n\n![](fujisan/26.jpg)\n有點後悔沒來這個神社蓋朱印\n\n![](fujisan/24.jpg)\n又一個人生清單達成！\n\n在附近賣店吃完東西後就趕緊下山了\n\n不然山上雨跟霧越來越大，溫度也越來越低\n\n下山可以選擇接駁下山或是自己騎下山\n\n下山也是分梯次，然後下山真的靠杯冷....(後悔沒搭接駁車)\n\n回到山腳的起點會有熱烏龍麵（但我沒看到）\n\n因為我急忙去服務台辦理證明想說早點回去洗澡\n\n完賽證明的部分\n\n![](fujisan/27.jpg)\n\n有完賽的人會有一個金屬的龍頭墊圈（單車的一個零件）\n\n沒有獎牌只有完賽證明\n\n然後那個龍頭墊圈有分\n\n金環：65分鐘內完賽  \n銀環：75分鐘內完賽  \n銅環：90分鐘內完賽  \n藍環：男子組完賽  \n粉環：女子組完賽  \n\n本廢物騎了141分鐘...只能領藍環\n\n大會還說歷年完賽率是99% (我開始懷疑這個說法了...)\n\n算了！我本來就是來輕鬆騎的\n\n這次挑戰的路線（上山+下山）\n\n<iframe height='405' width='590' frameborder='0' allowtransparency='true' scrolling='no' src='https://www.strava.com/activities/2435246405/embed/5237a9b224bb00a0d3aa3625acedcb90dc693fe0'></iframe>\n\nRelive影片-我是不知道那個最高速123km/h怎麼來的XD\n\n<blockquote class=\"embedly-card\" data-card-controls=\"0\" data-card-key=\"f1631a41cb254ca5b035dc5747a5bd75\"><h4><a href=\"https://www.relive.cc/view/vKv244Rxk46?r=embed-site\">Relive '富士山ヒルクライム'</a></h4></blockquote>\n<script async src=\"https://cdn.embedly.com/widgets/platform.js\" charset=\"UTF-8\"></script>\n\n\n另外必須補充很重要的一點\n\n<font color=\"#dd0000\" size=\"6\">Mt.富士ヒルクライム這個挑戰賽全程的補給只有\"水\"</font>\n\n<font color=\"#dd0000\" size=\"6\">Mt.富士ヒルクライム這個挑戰賽全程的補給只有\"水\"</font>\n\n<font color=\"#dd0000\" size=\"6\">Mt.富士ヒルクライム這個挑戰賽全程的補給只有\"水\"</font>\n\n\n很重要,講三遍!\n\n沒錯就只有水，沒有其他任何補給，簡章上也沒寫，所以基本上我騎到四合目時就沒力了\n\n因為我沒帶補給品，早餐只吃一個菠蘿跟一杯咖啡就上了\n\n然後因為比較晚出發的關係\n\n爬到一半已經有人下滑了\n\n而且又差點被別人亂丟的水壺拌倒\n\n有在騎車的人應該知道這種心情會很差\n\n雖然知道在國外騎車不能跟台灣本地賽事做比較\n\n但老實說Mt.富士ヒルクライム在這方面做得並不好\n\n也必須強調不是日本人辦的活動就一定很好\n\n我同事也是因為沒有補給騎到四合目直接進餐廳飽餐一頓再上山\n\n下山後回到旅館，整個騎的很狼狽\n\n![](fujisan/28.jpg)\n\n還好我是帶鋁合金輪組來（不然這種惡劣天氣下坡用碳纖維輪組很傷）\n\n辛苦了我的小綠！！\n\n回到旅館沒事就先把車拆一拆裝回車箱\n\n準備明天回到東京\n\n然後在這邊感謝在旅館打工的當地住民-山中先生\n\n請他載我們跟車箱運到車站（我可不想在雨中拖著車箱走到車站）\n\n回程途中，山中先生說我們運氣很差，剛好來的這幾天都在下雨\n\n![](fujisan/29.jpg)  \n果然也一堆人擠在河口湖站\n\n雨天哪也去不了\n\n![](fujisan/30.jpg)\n\n一樣也是搭富士急行的バス回到新宿\n\n回到新宿依然在下雨\n\n趕緊到入住的旅館放行李\n\n房間一個人住很可以\n\n![](fujisan/31.jpg)\n\n因為算是蠻常來日本的其實也沒什麼購物行程\n\n就隨便逛逛\n\n去神社參拜蓋個朱印\n\n![](fujisan/32.jpg)\n\n晚上最後一餐就用新宿拉麵名店-風雲兒做為結束！！！\n\n![](fujisan/33.jpg)\n\n然後人生最漚就是\n\n隔天要回台灣天氣才放晴\n\n.....感覺是嘲笑我傻啊.....\n\n![](fujisan/34.jpg)\n\n這趟旅行又達成了一個成就\n\n來到富士山，爬上富士山，但卻沒看過富士山\n\n看來我真的沒緣份呢！"
    }
  ]
}